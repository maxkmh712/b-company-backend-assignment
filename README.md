# B 회사 과제

## [ 도입 ]

총 6문제를 NestJS 하나의 앱 안에서 각각 하나의 독립적인 폴더를 생성하여 구현하였습니다.
API 구현문제 3개는 src 폴더 하위에 TypeScript와 NestJS를 사용하여 구현하였고,
SQL 문제 3개는 sql 폴더 하위에 SQL raw Query를 사용하여 구현하였습니다.

---

## [ API 로컬 테스트 방법 ]

### 1. 해당 레포지토리 클론

### 2. 필요한 패키지 다운로드

```bash
$ yarn install
```

### 3. 로컬 서버 실행

```bash
# watch mode
$ yarn run start:local
```

### 4. 요청 테스트를 용이하게 하기 위해 postman을 사용하여 테스트 케이스를 정리하여 문서를 배포해두었습니다.

---

## [ 과제 1. 개인정보 유효기간 ]

GET /privacy-expiration?today={today}&terms={terms}&privacies={privacies}

- `privacy-expiration`이라는 폴더에 API를 구현하였습니다.

- dto : `오늘날짜(today)`, `약관 유효기간의 정보(terms)`, `개인정보의 정보(privacies)` 매개변수는 쿼리파라미터로 받을 수 있도록 구현하였습니다. 이 3가지 쿼리파라미터는 하나의 QueryDto 안에서 관리할 수 있도록 커스텀하였습니다. 각 매개변수는 각각의 타입과 필수여부를 체크하여 QueryDto 안에서 class-validator를 사용하여 컨트롤러 진입 전에 검증되도록 구현하였습니다.

- controller : API 구현과제라는 의미에 맞춰 MVC 패턴을 사용하여 컨트롤러 단에서 요청을 받고, 문제 해결 로직은 서비스 단으로 분리하였습니다.

- service : 싱글톤 패턴을 사용하는 NestJS에 맞게 `PrivacyExpirationService`이라는 싱글톤 서비스를 정의하고 문제를 해결에 필요한 메소드들을 최대한 객체지향적으로 구현하고자 하였습니다.

  - public, private과 같은 접근 제어자를 통해 캡슐화 원칙을 지키고자 하였습니다
  - 각각의 메소드들은 SRP원칙에 따라 고유하고 독립적인 기능만 실행하도록 설계하고자 하였고, 이를 통해 재사용성과 유지보수를 용이하게 하고자 하였습니다.
  - 각각의 메소드들에는 함수명에 마우스 호버시 간단한 설명을 확인할 수 있도록 주석을 달았습니다.
  - 모든 함수의 인자, 로직, 반환값 등 최대한 타입을 구체적으로 명시하여 안정성을 높이고자 하였습니다.
  - 로직 설명 : 이 문제에서 중요하게 생각했던 부분은 한달이 28일로 설정된 부분이었습니다. 때문에 라이브러리를 쓰지 않고 일,월,년의 변화에 따른 예외 케이스를 고려하여 직접 로직을 구현하였습니다. 자세한 코드에 주석을 달아두었으니 참고 부탁드리겠습니다.

- postman API 명세 및 테스트 : https://documenter.getpostman.com/view/17666851/2sAXjM5XSp

---

## [ 과제 2. 예산 ]

GET /budget?d={d}&budget={budget}

- `budget`이라는 폴더에 API를 구현하였습니다.

- dto : `부서별 신청 금액(d)`, `예산(budget)` 매개변수는 쿼리파라미터로 받을 수 있도록 구현하였습니다. 마찬가지로 커스텀한 QueryDto를 생성하여 하나의 DTO로 컨트롤러 진입 전에 입력값들의 조건들이 검증될 수 있도록 구현하였습니다.

- controller : 마찬가지로 컨트롤러에서는 서비스 로직 진입 전 요청을 처리하는 역할로 구현하였습니다.

- service : 간단한 로직이라고 생각하여 하나의 함수에서 구현하였습니다.

  - 로직 설명 : 우선적으로 부서별 신청금액을 오름차순으로 정렬하였습니다. 그 이유는, 최대한 많은 부서를 지원해주기 위해선 신청금액이 작은 금액부터 지원해줘야 그 최대 수가 많아지기 때문입니다. 이후 신청금액 배열을 작은 것부터 순회하면서 현재 사용된 예산에 더해 예산보다 크지 않으면 지원받을 수 있다고 판단하고 해당값을 1 증가시키고 동시에 사용된 금액도 증가시켰습니다. 최종적으로 총 사용된 금액이 예산보다 커질 때 순회를 종료하고 그때의 최대 부서수를 반환하도록 설계하였습니다.

- postman API 명세 및 테스트 : https://documenter.getpostman.com/view/17666851/2sAXjNXAS3

---

## [ 과제 3. 할인행사 ]

GET /discount-event?want={want}&number={number}&discount={discount}

- discount-event라는 폴더에 API를 구현하였습니다.

- dto : `원하는 제품 목록(want)`, `원하는 제품 수량(number)`, `할인하는 제품 목록(discount)` 매개변수는 쿼리파라미터로 받을 수 있도록 구현하였습니다. 이 부분에서 number의 합은 10이라는 제한 사항을 설정하기 위해 커스텀 데코레이터를 활용하였습니다. 합이 10인지를 확인하는 함수를 별도의 파일로 만든 뒤, 데코레이터로 사용할 수 있게 설정하고 해당 DTO의 쿼리파라미터에 @TotalSumTen() 라는 커스텀 데코레이터를 붙여 유효성 검증이 이루어지도록 구현하였습니다.

- controller : 위 문제들의 컨트롤러와 기능이 동일합니다.

- service : 최대한 타입을 명시하려 했고, 객체 지향적으로 구현하고자 하였습니다.

  - 로직 설명 : 원하는 목록의 상품명과 수량으로 wantMap을 만들고, 할인하는 제품 목록에서 슬라이딩 윈도우 알고리즘을 활용하여 10개씩 묶어 discountMap을 만들었습니다. 그 후 wantMap에 있는 제품과 수량이 discountMap의 제품과 수량과 같은지를 검증하는 방식으로 구현하였습니다.

- postman API 명세 및 테스트 : https://documenter.getpostman.com/view/17666851/2sAXjQ1qDH

## [ 과제 4. 가격대별 상품개수 ]

- `4.product-count-by-price.sql` 파일에 쿼리 및 주석을 달아두었습니다.

## [ 과제 5. 월 총매출 조회 ]

- `5.total-sales.sql` 파일에 쿼리 및 주석을 달아두었습니다.

## [ 과제 6. 재구매 회원 리스트 ]

- `6.repurchase-user-list.sql` 파일에 쿼리 및 주석을 달아두었습니다.
